package sysc3033.group9.elevatorproject.system;

import sysc3033.group9.elevatorproject.constants.SleepTime;
import sysc3033.group9.elevatorproject.constants.elevator.MotorStatus;
import sysc3033.group9.elevatorproject.elevator.Elevator;
import sysc3033.group9.elevatorproject.floor.FloorSpan;
import sysc3033.group9.elevatorproject.util.Sleeper;

public class ElevatorSystem implements Runnable {
	private CommunicationPipe pipe;
	private boolean isMoving;
	private int currentFloor;
	private Elevator elevator;

	public ElevatorSystem(FloorSpan floorSpan, CommunicationPipe pipe) {
		this.elevator = new Elevator(floorSpan);
		this.currentFloor = floorSpan.getMinFloorID();
		this.pipe = pipe;
		this.isMoving = false;
	}

	@Override
	public void run() {
		while (true) {
			if (pipe.isSchedulerToElevator()) {
				handleElevatorEvent();
			} else if (isMoving) {
				handleMove();
			}
			Sleeper.sleep(SleepTime.DEFAULT);
		}
	}

	private void handleElevatorEvent() {
		/**
		 * TODO if the elevator is not moving, update the motor to go in the
		 * corresponding direction otherwise process the stop generated by the scheduler
		 */
		MotorStatus status = elevator.getMotor().getStatus();
		// int floorToMove=pipe.getFloor
		if (status == MotorStatus.IDLE) {
			// if(currentFloor<)
			System.out.println(Thread.currentThread().getName() + " has received the signal and is currently moving.");
			pipe.setSchedulerToElevator(false);
			isMoving = true;
		}
	}

	private void handleMove() {
		/*
		 * TODO Once the elevator starts moving, it must update the lamps to the
		 * scheduler which will then notify the the floor subsystem
		 */
		System.out.println(Thread.currentThread().getName() + " has signaled the lamps to the Scheduler.");
		pipe.elevatorToFloor();
		isMoving = false;
	}

}
